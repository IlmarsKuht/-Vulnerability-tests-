#include "pch.h"
#include "proc.h"
#include "mem.h"

// Created with ReClass.NET 1.2 by KN4CK3R

struct Vector3 { float x, y, z; };

class ent
{
public:
    Vector3 posHead; //0x0004
    char pad_0010[24]; //0x0010
    Vector3 posBody; //0x0028
    Vector3 angle; //0x0034
    char pad_0040[172]; //0x0040
    int32_t health; //0x00EC
    char pad_00F0[277]; //0x00F0
    char name[16]; //0x0205
    char pad_0215[335]; //0x0215
    class weapon* currWeapon; //0x0364

    virtual void Function0();
    virtual void Function1();
    virtual void Function2();
    virtual void Function3();
    virtual void Function4();
    virtual void Function5();
    virtual void Function6();
    virtual void Function7();
    virtual void Function8();
    virtual void Function9();
}; //Size: 0x0368
static_assert(sizeof(ent) == 0x368);

class weapon
{
public:
    char pad_0000[20]; //0x0000
    class ammoclip* ammoptr; //0x0014
    char pad_0018[4]; //0x0018
}; //Size: 0x001C
static_assert(sizeof(weapon) == 0x1C);

class ammoclip
{
public:
    int32_t ammo; //0x0000
}; //Size: 0x0004
static_assert(sizeof(ammoclip) == 0x4);

int main()
{
    HANDLE hProcess = 0;

    uintptr_t moduleBase = 0, localPlayerPtr = 0, healthAddr = 0;
    bool bHealth = false, bAmmo = false, bRecoil = false;

    const int newValue = 1337;

    DWORD procId = GetProcId(L"ac_client.exe");

    if (procId)
    {
        hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, procId);

        moduleBase = GetModuleBaseAddress(procId, L"ac_client.exe");

        localPlayerPtr = moduleBase + 0x195404;

        healthAddr = FindDMAAddy(hProcess, localPlayerPtr, { 0xec });
    }
    else 
    {
        std::cout << "Process not found, press enter to exit\n";
        getchar();
        return 0;
    }

    DWORD dwExit = 0;

    while (GetExitCodeProcess(hProcess, &dwExit) && dwExit == STILL_ACTIVE)
    {
        if (GetAsyncKeyState(VK_F1) & 1)
        {
            bHealth = !bHealth;
        }
        if (GetAsyncKeyState(VK_F2) & 1)
        {
            std::cout << "AMMO" << std::endl;
            bAmmo = !bAmmo;

            if (bAmmo)
            {   
                //ff 00 = inc [eax]
                mem::PatchEx((BYTE*)(moduleBase + 0xc73ef), (BYTE*)"\xFF\x00", 2, hProcess);
            }
            else 
            {
                //ff 08 = dec [esi]
                mem::PatchEx((BYTE*)(moduleBase + 0xc73ef), (BYTE*)"\xFF\x08", 2, hProcess);
            }
        }
        if (GetAsyncKeyState(VK_F3) & 1)
        {
            bRecoil = !bRecoil;

            if (bRecoil)
            {
                mem::NopEx((BYTE*)(moduleBase + 0x63786), 10, hProcess);
            }
            else
            {
                // \x tells to use literal bytes written
                mem::PatchEx((BYTE*)(moduleBase + 0x63786), (BYTE*)"\x50\x8d\x4c\x24\x1c\x51\x8b\xce\xff\xd2", 10, hProcess);
            }
        }
        if (GetAsyncKeyState(VK_F4) & 1)
        {
            return 0;
        }

        //continuous write or freeze
        if (bHealth)
        {
            mem::PatchEx((BYTE*)healthAddr, (BYTE*)&newValue, sizeof(newValue), hProcess);
        }

        Sleep(10);
    }

    std::cout << "Process not found, press enter to exit\n";
    getchar();
    return 0;
}